<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Video Merge Load Tester</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/piexifjs@1.0.6/piexif.min.js"></script>
  <script src="ffmpeg/ffmpeg.js"></script>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      line-height: 1.6;
      color: #333;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }

    .container {
      max-width: 900px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      padding: 40px;
    }

    h1 {
      color: #667eea;
      margin-bottom: 10px;
    }

    .subtitle {
      color: #666;
      margin-bottom: 30px;
    }

    .config-section {
      background: #f8f9fa;
      border: 2px solid #dee2e6;
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 25px;
    }

    .config-row {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
      gap: 15px;
    }

    .config-row label {
      min-width: 200px;
      font-weight: 600;
    }

    .config-row input,
    .config-row select {
      padding: 8px;
      border: 2px solid #667eea;
      border-radius: 4px;
      font-size: 14px;
      flex: 1;
    }

    .btn {
      background: #667eea;
      color: white;
      padding: 12px 30px;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s;
    }

    .btn:hover {
      background: #5568d3;
      transform: translateY(-2px);
    }

    .btn:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }

    .btn-stop {
      background: #dc3545;
    }

    .btn-stop:hover {
      background: #c82333;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 25px;
    }

    .stat-box {
      background: #f8f9fa;
      border-left: 4px solid #667eea;
      padding: 15px;
      border-radius: 4px;
    }

    .stat-label {
      color: #666;
      font-size: 12px;
      text-transform: uppercase;
    }

    .stat-value {
      color: #333;
      font-size: 24px;
      font-weight: bold;
    }

    .progress-bar {
      background: #e9ecef;
      border-radius: 10px;
      height: 30px;
      overflow: hidden;
      margin-bottom: 15px;
    }

    .progress-fill {
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      height: 100%;
      width: 0%;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 14px;
    }

    .log {
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      padding: 15px;
      max-height: 400px;
      overflow-y: auto;
      font-family: "Courier New", monospace;
      font-size: 13px;
    }

    .log-entry {
      margin-bottom: 5px;
    }

    .log-entry.success {
      color: #28a745;
    }

    .log-entry.error {
      color: #dc3545;
    }

    .log-entry.warning {
      color: #ffc107;
    }

    .log-entry.info {
      color: #666;
    }

    .warning-box {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin-bottom: 20px;
      border-radius: 4px;
    }

    input[type="file"] {
      display: none;
    }

    .file-label {
      display: inline-block;
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s;
    }

    .file-label:hover {
      background: #218838;
    }
  </style>
</head>

<body>
  <div class="container">
    <h1>Video Merge Load Tester</h1>
    <p class="subtitle">
      Stress test video merging to identify memory issues and performance bottlenecks
    </p>

    <div class="warning-box">
      <strong>‚ö†Ô∏è Warning:</strong> This tool will repeatedly download and merge the same video to stress test your
      system. It may consume significant memory and CPU. Monitor your browser's performance.
    </div>

    <div style="background: #e7f3ff; border-left: 4px solid #667eea; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
      <strong>‚ÑπÔ∏è What This Tests:</strong>
      <p style="margin-top: 10px; font-size: 14px;">
        This load tester processes videos <strong>one at a time</strong> and discards each result immediately.
        This is different from the main tool which accumulates ALL processed videos in a JSZip object until
        the batch completes.
      </p>
      <p style="margin-top: 10px; font-size: 14px;">
        <strong>Main tool memory usage:</strong> Batch of 50 videos = 50 videos √ó 50MB = 2.5GB held in RAM<br>
        <strong>Load tester memory usage:</strong> 50 iterations = Only 1 video (50MB) in RAM at a time
      </p>
      <p style="margin-top: 10px; font-size: 14px;">
        Use this to isolate FFmpeg WASM issues from JSZip memory accumulation issues.
      </p>
    </div>

    <div class="config-section">
      <h3 style="margin-bottom: 15px">Configuration</h3>

      <div class="config-row">
        <label>Upload memories_history.html:</label>
        <input type="file" id="htmlFileInput" accept=".html" />
        <label for="htmlFileInput" class="file-label">Choose File</label>
        <span id="htmlFileName" style="color: #28a745; font-weight: 600;"></span>
      </div>

      <div class="config-row">
        <label>Number of iterations:</label>
        <input type="number" id="iterationsInput" value="20" min="1" max="100" />
      </div>

      <div class="config-row">
        <label>FFmpeg reset interval:</label>
        <select id="resetIntervalInput">
          <option value="1">Every video (safest, slowest)</option>
          <option value="3">Every 3 videos</option>
          <option value="5" selected>Every 5 videos (recommended)</option>
          <option value="10">Every 10 videos</option>
          <option value="999">Never reset (will likely fail)</option>
        </select>
      </div>

      <div class="config-row">
        <label>Delay between videos (ms):</label>
        <input type="number" id="delayInput" value="2000" min="0" max="10000" step="100" />
      </div>

      <div class="config-row">
        <label>Memory check interval:</label>
        <input type="number" id="memCheckInput" value="5" min="1" max="50" />
        <span style="color: #666; font-size: 14px;">Check every N iterations</span>
      </div>

      <div style="margin-top: 20px; display: flex; gap: 10px;">
        <button id="startButton" class="btn" onclick="startTest()" disabled>Start Test</button>
        <button id="stopButton" class="btn btn-stop" onclick="stopTest()" disabled>Stop Test</button>
      </div>
    </div>

    <div class="stats">
      <div class="stat-box">
        <div class="stat-label">Total Iterations</div>
        <div class="stat-value" id="totalIterations">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Successful</div>
        <div class="stat-value" id="successCount" style="color: #28a745;">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Failed</div>
        <div class="stat-value" id="failCount" style="color: #dc3545;">0</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Avg Time (s)</div>
        <div class="stat-value" id="avgTime">-</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">Memory Used</div>
        <div class="stat-value" id="memoryUsed" style="font-size: 18px;">-</div>
      </div>
      <div class="stat-box">
        <div class="stat-label">FFmpeg Resets</div>
        <div class="stat-value" id="resetCount">0</div>
      </div>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" id="progressFill">0%</div>
    </div>

    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
      <div style="color: #666; font-size: 14px; font-weight: 600;">Test Log</div>
      <button class="btn" style="padding: 6px 15px; font-size: 13px;" onclick="copyLogsToClipboard()">
        üìã Copy Logs
      </button>
    </div>

    <div class="log" id="log"></div>
  </div>

  <script>
    let ffmpegInstance = null;
    let ffmpegLoaded = false;
    let videosProcessedSinceReset = 0;
    let totalResets = 0;

    let videoUrl = null;
    let isRunning = false;
    let shouldStop = false;

    let stats = {
      total: 0,
      success: 0,
      failed: 0,
      times: []
    };

    // File input handler
    document.getElementById('htmlFileInput').addEventListener('change', async (e) => {
      if (e.target.files.length > 0) {
        const file = e.target.files[0];
        document.getElementById('htmlFileName').textContent = file.name;
        const text = await file.text();
        parseHTML(text);
      }
    });

    function parseHTML(htmlText) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(htmlText, "text/html");
      const rows = doc.querySelectorAll("tr");

      for (const row of rows) {
        const cells = row.querySelectorAll("td");
        if (cells.length >= 4) {
          const link = cells[3].querySelector("a");
          if (link) {
            const onclickAttr = link.getAttribute("onclick");
            const urlMatch = onclickAttr ? onclickAttr.match(/downloadMemories\('([^']+)'/) : null;
            if (urlMatch) {
              videoUrl = urlMatch[1];
              addLog(`Found video URL: ${videoUrl.substring(0, 50)}...`, 'success');
              document.getElementById('startButton').disabled = false;
              return;
            }
          }
        }
      }

      addLog('No video URL found in HTML file!', 'error');
    }

    async function startTest() {
      if (isRunning) return;

      isRunning = true;
      shouldStop = false;
      stats = { total: 0, success: 0, failed: 0, times: [] };
      totalResets = 0;
      videosProcessedSinceReset = 0;

      document.getElementById('startButton').disabled = true;
      document.getElementById('stopButton').disabled = false;

      const iterations = parseInt(document.getElementById('iterationsInput').value);
      addLog(`Starting load test: ${iterations} iterations`, 'info');
      addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');

      for (let i = 1; i <= iterations; i++) {
        if (shouldStop) {
          addLog('Test stopped by user', 'warning');
          break;
        }

        const startTime = Date.now();
        addLog(`\n[${i}/${iterations}] Starting iteration...`, 'info');

        try {
          await processVideo(i);
          const duration = (Date.now() - startTime) / 1000;
          stats.success++;
          stats.times.push(duration);
          addLog(`[${i}/${iterations}] ‚úì Success (${duration.toFixed(2)}s)`, 'success');
        } catch (error) {
          const duration = (Date.now() - startTime) / 1000;
          stats.failed++;
          stats.times.push(duration);
          addLog(`[${i}/${iterations}] ‚úó Failed: ${error.message} (${duration.toFixed(2)}s)`, 'error');
        }

        stats.total++;
        updateStats(i, iterations);

        // Check memory
        const memCheckInterval = parseInt(document.getElementById('memCheckInput').value);
        if (i % memCheckInterval === 0) {
          checkMemoryUsage();
        }

        // Delay between iterations
        if (i < iterations) {
          const delay = parseInt(document.getElementById('delayInput').value);
          if (delay > 0) {
            addLog(`  Pausing ${delay}ms for garbage collection...`, 'info');
            await new Promise(resolve => setTimeout(resolve, delay));
          }
        }
      }

      addLog('\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
      addLog(`Test complete! Success: ${stats.success}, Failed: ${stats.failed}`, 'info');
      const avgTime = stats.times.reduce((a, b) => a + b, 0) / stats.times.length;
      addLog(`Average time per merge: ${avgTime.toFixed(2)}s`, 'info');
      addLog(`Total FFmpeg resets: ${totalResets}`, 'info');

      isRunning = false;
      document.getElementById('startButton').disabled = false;
      document.getElementById('stopButton').disabled = true;
    }

    function stopTest() {
      shouldStop = true;
      addLog('Stopping test after current iteration...', 'warning');
      document.getElementById('stopButton').disabled = true;
    }

    async function processVideo(iteration) {
      // Download video
      addLog('  Downloading video...', 'info');
      const response = await fetch(videoUrl);
      if (!response.ok) throw new Error(`HTTP ${response.status}`);

      const blob = await response.blob();
      const arrayBuffer = await blob.arrayBuffer();

      // Check if ZIP
      const uint8Array = new Uint8Array(arrayBuffer);
      const isZip = uint8Array[0] === 0x50 && uint8Array[1] === 0x4b;

      if (!isZip) {
        throw new Error('Not a ZIP file (no overlay to merge)');
      }

      // Extract ZIP
      addLog('  Extracting ZIP...', 'info');
      const zip = await JSZip.loadAsync(arrayBuffer);
      const files = Object.keys(zip.files);

      if (files.length !== 2) {
        throw new Error(`Expected 2 files in ZIP, got ${files.length}`);
      }

      // Get main and overlay
      let mainData = null;
      let overlayData = null;
      let overlayName = null;

      for (const filename of files) {
        const fileData = await zip.files[filename].async('arraybuffer');
        if (filename.toLowerCase().includes('overlay')) {
          overlayData = fileData;
          overlayName = filename;
        } else {
          mainData = fileData;
        }
      }

      if (!mainData || !overlayData) {
        throw new Error('Missing main or overlay file');
      }

      // Determine overlay type
      let overlayExt = overlayName && overlayName.includes('.')
        ? overlayName.substring(overlayName.lastIndexOf('.'))
        : '.mp4';
      const detectedExt = detectFileExtension(new Uint8Array(overlayData));
      if (detectedExt) overlayExt = detectedExt;

      const overlayExtNoDot = overlayExt.replace('.', '').toLowerCase();
      const overlayIsImage = ['png', 'jpg', 'jpeg', 'webp', 'gif'].includes(overlayExtNoDot);

      addLog(`  Overlay type: ${overlayIsImage ? 'image' : 'video'} (${overlayExt})`, 'info');

      // Merge
      addLog('  Merging with FFmpeg...', 'info');
      const mergedData = await mergeVideoOverlay(mainData, overlayData, overlayIsImage, overlayExt);

      addLog(`  Merged size: ${(mergedData.byteLength / 1024 / 1024).toFixed(2)}MB`, 'info');
    }

    async function mergeVideoOverlay(mainData, overlayData, overlayIsImage, overlayExt) {
      const ffmpeg = await initFFmpeg();

      let overlayFilename;
      try {
        await ffmpeg.writeFile("main.mp4", new Uint8Array(mainData));
        overlayFilename = overlayIsImage ? `overlay${overlayExt}` : 'overlay.mp4';
        await ffmpeg.writeFile(overlayFilename, new Uint8Array(overlayData));

        let args;
        if (overlayIsImage) {
          args = [
            "-i", "main.mp4",
            "-loop", "1",
            "-i", overlayFilename,
            "-filter_complex",
            `[1:v]scale=iw:ih[ovr];[0:v][ovr]overlay=x=(main_w-overlay_w)/2:y=(main_h-overlay_h)/2:format=auto:shortest=1[outv]`,
            "-map", "[outv]",
            "-map", "0:a?",
            "-c:v", "libx264",
            "-preset", "ultrafast",
            "-crf", "23",
            "-pix_fmt", "yuv420p",
            "-c:a", "copy",
            "-movflags", "+faststart",
            "-y", "output.mp4"
          ];
        } else {
          // overlay is a video - use scale2ref to match dimensions
          args = [
            "-i", "main.mp4",
            "-i", overlayFilename,
            "-filter_complex",
            "[0:v]fps=30,setsar=1[base];[1:v]fps=30,setsar=1,loop=loop=-1:size=32767:start=0,setpts=N/FRAME_RATE/TB[ovr_tmp];[ovr_tmp][base]scale2ref[ovr][base];[base][ovr]overlay=format=auto:shortest=1[outv]",
            "-map", "[outv]",
            "-map", "0:a?",
            "-c:v", "libx264",
            "-preset", "ultrafast",
            "-crf", "23",
            "-pix_fmt", "yuv420p",
            "-c:a", "copy",
            "-movflags", "+faststart",
            "-y", "output.mp4"
          ];
        }

        await ffmpeg.exec(args);
        const outputData = await ffmpeg.readFile("output.mp4");

        await ffmpeg.deleteFile("main.mp4").catch(() => { });
        if (overlayFilename) await ffmpeg.deleteFile(overlayFilename).catch(() => { });
        await ffmpeg.deleteFile("output.mp4").catch(() => { });

        videosProcessedSinceReset++;
        return outputData.buffer;
      } catch (error) {
        await ffmpeg.deleteFile("main.mp4").catch(() => { });
        if (overlayFilename) await ffmpeg.deleteFile(overlayFilename).catch(() => { });
        await ffmpeg.deleteFile("output.mp4").catch(() => { });

        addLog('  Video merge failed, resetting FFmpeg...', 'warning');
        await terminateFFmpeg();
        throw error;
      }
    }

    async function initFFmpeg(forceReload = false) {
      const resetInterval = parseInt(document.getElementById('resetIntervalInput').value);

      if (forceReload || (videosProcessedSinceReset >= resetInterval && resetInterval < 999)) {
        if (ffmpegInstance) {
          addLog(`  Resetting FFmpeg after ${videosProcessedSinceReset} videos`, 'info');
          await terminateFFmpeg();
          totalResets++;
          document.getElementById('resetCount').textContent = totalResets;
        }
      }

      if (ffmpegLoaded && ffmpegInstance) {
        return ffmpegInstance;
      }

      const { FFmpeg } = FFmpegWASM;
      ffmpegInstance = new FFmpeg();

      addLog('  Loading FFmpeg.wasm...', 'info');
      await ffmpegInstance.load({
        coreURL: new URL('./ffmpeg/ffmpeg-core.js', window.location).href,
        wasmURL: new URL('./ffmpeg/ffmpeg-core.wasm', window.location).href,
        worker: false
      });

      ffmpegLoaded = true;
      videosProcessedSinceReset = 0;
      addLog('  FFmpeg loaded', 'success');
      return ffmpegInstance;
    }

    async function terminateFFmpeg() {
      if (ffmpegInstance) {
        ffmpegInstance.off('log');
        ffmpegInstance.off('progress');
        ffmpegInstance = null;
        ffmpegLoaded = false;
        videosProcessedSinceReset = 0;
        await new Promise(resolve => setTimeout(resolve, 500));
      }
    }

    function detectFileExtension(uint8array) {
      if (!uint8array || uint8array.length < 12) return null;
      if (uint8array[0] === 0x89 && uint8array[1] === 0x50) return '.png';
      if (uint8array[0] === 0xff && uint8array[1] === 0xd8) return '.jpg';
      if (uint8array[0] === 0x52 && uint8array[1] === 0x49 && uint8array[8] === 0x57) return '.webp';
      if (uint8array[0] === 0x47 && uint8array[1] === 0x49) return '.gif';
      if (uint8array[4] === 0x66 && uint8array[5] === 0x74 && uint8array[6] === 0x79 && uint8array[7] === 0x70) return '.mp4';
      return null;
    }

    function checkMemoryUsage() {
      try {
        if (performance.memory) {
          const usedMB = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
          const limitMB = Math.round(performance.memory.jsHeapSizeLimit / 1024 / 1024);
          const percentUsed = Math.round((usedMB / limitMB) * 100);

          document.getElementById('memoryUsed').textContent = `${usedMB}MB / ${limitMB}MB`;
          document.getElementById('memoryUsed').style.color = percentUsed > 80 ? '#dc3545' : percentUsed > 60 ? '#ffc107' : '#28a745';

          if (percentUsed > 80) {
            addLog(`  ‚ö†Ô∏è Memory critical: ${usedMB}MB / ${limitMB}MB (${percentUsed}%)`, 'warning');
          } else {
            addLog(`  Memory: ${usedMB}MB / ${limitMB}MB (${percentUsed}%)`, 'info');
          }
        }
      } catch (e) {
        // Not available in all browsers
      }
    }

    function updateStats(current, total) {
      document.getElementById('totalIterations').textContent = stats.total;
      document.getElementById('successCount').textContent = stats.success;
      document.getElementById('failCount').textContent = stats.failed;

      if (stats.times.length > 0) {
        const avgTime = stats.times.reduce((a, b) => a + b, 0) / stats.times.length;
        document.getElementById('avgTime').textContent = avgTime.toFixed(2);
      }

      const percent = Math.round((current / total) * 100);
      document.getElementById('progressFill').style.width = `${percent}%`;
      document.getElementById('progressFill').textContent = `${percent}%`;
    }

    function addLog(message, type = 'info') {
      const log = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = message;
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
    }

    async function copyLogsToClipboard() {
      const logEntries = document.querySelectorAll('.log-entry');
      const logText = Array.from(logEntries)
        .map(entry => entry.textContent)
        .join('\n');

      try {
        await navigator.clipboard.writeText(logText);
        addLog('‚úÖ Logs copied to clipboard!', 'success');
      } catch (err) {
        // Fallback for older browsers
        const textarea = document.createElement('textarea');
        textarea.value = logText;
        textarea.style.position = 'fixed';
        textarea.style.opacity = '0';
        document.body.appendChild(textarea);
        textarea.select();

        try {
          document.execCommand('copy');
          addLog('‚úÖ Logs copied to clipboard!', 'success');
        } catch (e) {
          addLog('‚ùå Failed to copy logs. Please select and copy manually.', 'error');
        }

        document.body.removeChild(textarea);
      }
    }
  </script>
</body>

</html>
